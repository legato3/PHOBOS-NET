<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>NOC Wallboard - PHOBOS-NET</title>
    <script defer src="/static/js/modules/alpine.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css?v=5.0.1">
    <style>
        /* Wallboard-specific styles - Matches cyberpunk theme, readable sizes */
        body.wallboard {
            margin: 0;
            padding: var(--space-6);
            background: var(--bg-0);
            color: var(--text-0);
            font-family: var(--font-sans);
            overflow: auto;
            min-height: 100vh;
        }

        .wallboard-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: var(--space-6);
        }

        .wallboard-header {
            text-align: center;
            padding: var(--space-6) 0;
            border-bottom: 1px solid var(--border-soft);
        }

        .wallboard-header h1 {
            font-size: var(--text-3xl);
            margin: 0;
            color: var(--signal-primary);
            font-weight: var(--font-weight-semibold);
            letter-spacing: var(--letter-spacing-wide);
        }

        .wallboard-header .timestamp {
            font-size: var(--text-base);
            color: var(--text-secondary);
            margin-top: var(--space-2);
            font-family: var(--font-mono);
        }

        .wallboard-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-4);
        }

        .wallboard-stat {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--card-radius);
            padding: var(--space-5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: border-color var(--transition-base), box-shadow var(--transition-base);
        }

        .wallboard-stat.status-ok {
            border-color: var(--signal-ok);
            box-shadow: 0 0 8px var(--glow-ok);
        }

        .wallboard-stat.status-warning {
            border-color: var(--signal-warn);
            box-shadow: 0 0 8px var(--glow-warn);
        }

        .wallboard-stat.status-error {
            border-color: var(--signal-crit);
            box-shadow: 0 0 8px var(--glow-critical);
        }

        .wallboard-stat-label {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin-bottom: var(--space-3);
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wide);
            font-weight: var(--font-weight-medium);
        }

        .wallboard-stat-value {
            font-size: var(--text-3xl);
            font-weight: var(--font-weight-semibold);
            color: var(--text-0);
            line-height: var(--line-height-tight);
            font-family: var(--font-mono);
        }

        .wallboard-stat-value.status-ok {
            color: var(--signal-ok);
        }

        .wallboard-stat-value.status-warning {
            color: var(--signal-warn);
        }

        .wallboard-stat-value.status-error {
            color: var(--signal-crit);
        }

        .wallboard-health-large {
            grid-column: 1 / -1;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: var(--card-radius);
            padding: var(--space-6);
            text-align: center;
            transition: border-color var(--transition-base), box-shadow var(--transition-base);
        }

        .wallboard-health-large.status-ok {
            border-color: var(--signal-ok);
            box-shadow: 0 0 12px var(--glow-ok);
        }

        .wallboard-health-large.status-warning {
            border-color: var(--signal-warn);
            box-shadow: 0 0 12px var(--glow-warn);
        }

        .wallboard-health-large.status-error {
            border-color: var(--signal-crit);
            box-shadow: 0 0 12px var(--glow-critical);
        }

        .wallboard-health-label {
            font-size: var(--text-lg);
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wide);
            font-weight: var(--font-weight-medium);
        }

        .wallboard-health-state {
            font-size: var(--text-4xl);
            font-weight: var(--font-weight-bold);
            text-transform: uppercase;
            letter-spacing: var(--letter-spacing-wider);
            margin: var(--space-4) 0;
            font-family: var(--font-mono);
        }

        .wallboard-health-state.healthy {
            color: var(--signal-ok);
        }

        .wallboard-health-state.degraded {
            color: var(--signal-warn);
        }

        .wallboard-health-state.unhealthy {
            color: var(--signal-crit);
        }

        .wallboard-health-explanation {
            font-size: var(--text-base);
            color: var(--text-secondary);
            margin-top: var(--space-3);
            font-style: italic;
        }

        .wallboard-loading {
            font-size: var(--text-xl);
            color: var(--text-tertiary);
            text-align: center;
            padding: var(--space-6);
        }
    </style>
</head>

<body class="wallboard" x-data="wallboardStore()" x-init="init()">
    <div class="wallboard-container">
        <div class="wallboard-header">
            <h1>NETWORK OPERATIONS CENTER</h1>
            <div class="timestamp" x-text="now.toLocaleString()"></div>
            <div style="margin-top: var(--space-2); font-size: var(--text-sm); color: var(--text-tertiary);">
                PHOBOS-NET v2.0.0
            </div>
        </div>

        <div class="wallboard-stats">
            <!-- Overall Health (Large, Prominent) -->
            <div class="wallboard-health-large" :class="{
                    'status-ok': overallHealth.state === 'healthy',
                    'status-warning': overallHealth.state === 'degraded',
                    'status-error': overallHealth.state === 'unhealthy'
                }">
                <div class="wallboard-health-label">Overall System Health</div>
                <div class="wallboard-health-state" :class="overallHealth.state"
                    x-text="overallHealth.state === 'healthy' ? 'HEALTHY' : overallHealth.state === 'degraded' ? 'DEGRADED' : 'UNHEALTHY'">
                    HEALTHY
                </div>
                <template x-if="overallHealth.shortExplanation">
                    <div class="wallboard-health-explanation" x-text="overallHealth.shortExplanation"></div>
                </template>
            </div>

            <!-- Active Alerts -->
            <div class="wallboard-stat" :class="{ 'status-warning': alertHistory.active_count > 0 }">
                <div class="wallboard-stat-label">Active Alerts</div>
                <div class="wallboard-stat-value" :class="{ 'status-warning': alertHistory.active_count > 0 }"
                    x-text="alertHistory.loading ? '...' : (alertHistory.active_count || 0).toLocaleString()">
                    0
                </div>
            </div>

            <!-- Active Flows -->
            <div class="wallboard-stat">
                <div class="wallboard-stat-label">Active Flows</div>
                <div class="wallboard-stat-value"
                    x-text="networkStatsOverview.loading ? '...' : (networkStatsOverview.active_flows || 0).toLocaleString()">
                    0
                </div>
            </div>

            <!-- External Connections -->
            <div class="wallboard-stat">
                <div class="wallboard-stat-label">External Connections</div>
                <div class="wallboard-stat-value"
                    x-text="networkStatsOverview.loading ? '...' : (networkStatsOverview.external_connections || 0).toLocaleString()">
                    0
                </div>
            </div>

            <!-- Blocked Events (24h) -->
            <div class="wallboard-stat">
                <div class="wallboard-stat-label">Blocked Events (24h)</div>
                <div class="wallboard-stat-value"
                    x-text="firewallStatsOverview.loading ? '...' : (firewallStatsOverview.blocked_events_24h || 0).toLocaleString()">
                    0
                </div>
            </div>

            <!-- Network Anomalies (24h) -->
            <div class="wallboard-stat" :class="{ 'status-warning': networkStatsOverview.anomalies_count > 0 }">
                <div class="wallboard-stat-label">Network Anomalies (24h)</div>
                <div class="wallboard-stat-value" :class="{ 'status-warning': networkStatsOverview.anomalies_count > 0 }"
                    x-text="networkStatsOverview.loading ? '...' : (networkStatsOverview.anomalies_count || 0).toLocaleString()">
                    0
                </div>
            </div>
        </div>
    </div>

    <script>
        function wallboardStore() {
            return {
                alertHistory: { total: 0, active_count: 0, loading: true },
                networkStatsOverview: { active_flows: 0, external_connections: 0, anomalies_count: 0, loading: true },
                firewallStatsOverview: { blocked_events_24h: 0, loading: true },
                overallHealth: { state: 'healthy', shortExplanation: '' },
                refreshTimer: null,
                now: new Date(),

                async fetchAlertHistory() {
                    try {
                        const res = await fetch('/api/security/alerts/history');
                        if (res.ok) {
                            const d = await res.json();
                            this.alertHistory = {
                                total: d.total || 0,
                                active_count: d.active_count || 0,
                                loading: false
                            };
                        }
                    } catch (e) {
                        this.alertHistory.loading = false;
                    }
                },

                async fetchNetworkStatsOverview() {
                    try {
                        const res = await fetch('/api/network/stats/overview');
                        if (res.ok) {
                            const d = await res.json();
                            this.networkStatsOverview = {
                                active_flows: d.active_flows || 0,
                                external_connections: d.external_connections || 0,
                                anomalies_count: d.anomalies_count || 0,
                                loading: false
                            };
                        }
                    } catch (e) {
                        this.networkStatsOverview.loading = false;
                    }
                },

                async fetchFirewallStatsOverview() {
                    try {
                        const res = await fetch('/api/firewall/stats/overview');
                        if (res.ok) {
                            const d = await res.json();
                            this.firewallStatsOverview = {
                                blocked_events_24h: d.blocked_events_24h || 0,
                                loading: false
                            };
                        }
                    } catch (e) {
                        this.firewallStatsOverview.loading = false;
                    }
                },

                async fetchBaselineSignals() {
                    // Health reflects SYSTEM OPERABILITY, not network noise
                    // Healthy = all data sources responding
                    // Degraded = partial data availability
                    // Unhealthy = critical data source failure
                    try {
                        const res = await fetch('/api/server/health');
                        if (res.ok) {
                            const d = await res.json();
                            const issues = [];

                            // Check NetFlow (primary data source)
                            if (d.netflow?.status === 'stalled' || d.netflow?.stalled === true) {
                                issues.push('NetFlow stalled');
                            }

                            // Check syslog
                            if (d.syslog?.status === 'error' || d.syslog?.active === false) {
                                issues.push('Syslog inactive');
                            }

                            // Check database
                            if (d.database?.status === 'error' || d.database?.available === false) {
                                issues.push('Database error');
                            }

                            if (issues.length === 0) {
                                this.overallHealth = { state: 'healthy', shortExplanation: 'full visibility' };
                            } else if (issues.length >= 2 || issues.some(i => i.includes('NetFlow') || i.includes('Database'))) {
                                this.overallHealth = { state: 'unhealthy', shortExplanation: issues[0] };
                            } else {
                                this.overallHealth = { state: 'degraded', shortExplanation: issues[0] };
                            }
                        } else {
                            this.calculateSimpleHealth();
                        }
                    } catch (e) {
                        // Fallback to simple health calculation
                        this.calculateSimpleHealth();
                    }
                },

                calculateSimpleHealth() {
                    // Simple health check based on data availability
                    // If we got here, API calls succeeded = healthy
                    const hasFlows = this.networkStatsOverview.active_flows !== undefined;
                    const hasFirewall = this.firewallStatsOverview.blocked_events_24h !== undefined;

                    if (hasFlows && hasFirewall) {
                        this.overallHealth = { state: 'healthy', shortExplanation: 'systems operational' };
                    } else if (hasFlows || hasFirewall) {
                        this.overallHealth = { state: 'degraded', shortExplanation: 'partial visibility' };
                    } else {
                        this.overallHealth = { state: 'unhealthy', shortExplanation: 'data unavailable' };
                    }
                },

                async loadAll() {
                    await Promise.all([
                        this.fetchAlertHistory(),
                        this.fetchNetworkStatsOverview(),
                        this.fetchFirewallStatsOverview()
                    ]);
                    await this.fetchBaselineSignals();
                    if (!this.overallHealth.shortExplanation) {
                        this.calculateSimpleHealth();
                    }
                },

                init() {
                    // Initial load
                    this.loadAll();

                    // Auto-refresh every 30 seconds
                    this.refreshTimer = setInterval(() => {
                        this.loadAll();
                    }, 30000);

                    // Update timestamp every second
                    setInterval(() => {
                        this.now = new Date();
                    }, 1000);
                }
            };
        }
    </script>
</body>

</html>
